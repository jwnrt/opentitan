// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

use anyhow::{Context, Result};
use clap::{Args, Subcommand, ValueEnum};
use serde_annotate::Annotate;
use std::any::Any;
use std::fs;
use std::path::PathBuf;

use opentitanlib::app::command::CommandDispatch;
use opentitanlib::app::TransportWrapper;
use ot_certs::{codegen, template, x509};

/// Commands for interacting with certificates.
#[derive(Debug, Subcommand, CommandDispatch)]
pub enum CertificateCommand {
    /// Generate a certificate template.
    GenTemplate(GenTplCommand),
}

/// Generate a certificate template.
#[derive(Clone, Debug, ValueEnum)]
pub enum CertFormat {
    X509,
}

/// Generate a certificate template.
#[derive(Debug, Args)]
pub struct GenTplCommand {
    /// Filename of the template.
    template: PathBuf,
    /// Certificate format
    #[arg(long, value_enum, default_value_t = CertFormat::X509)]
    cert_format: CertFormat,
    /// Output directory path.
    output_dir: PathBuf,
}

impl CommandDispatch for GenTplCommand {
    fn run(
        &self,
        _context: &dyn Any,
        _transport: &TransportWrapper,
    ) -> Result<Option<Box<dyn Annotate>>> {
        let template_content = fs::read_to_string(&self.template).with_context(|| {
            format!(
                "Could not load the template file {}",
                self.template.display()
            )
        })?;
        let template =
            template::Template::from_hjson_str(&template_content).with_context(|| {
                format!("Failed to parse template file {}", self.template.display())
            })?;
        log::info!("template: {:#?}", template);
        let x509 = x509::generate_certificate(&template)?;
        log::info!("variables: {:#?}", x509.variables);
        let output_x509 = self.output_dir.join(format!("{}.pem", &template.name));
        /* Generate pem certificate for debugging and inspection */
        log::info!("Writing certificate to {}", output_x509.display());
        fs::write(output_x509, x509.cert)?;
        /* Generate a C file and a header. We do not include header guards and licences
         * since those can generated by the linter tools. */
        let sources = x509.variables.iter().map(|var| codegen::CGenerator::generate_fn(&template.name, var)).collect::<Vec<_>>();
        let c_source = sources.iter().map(|x| x.0.as_str()).collect::<Vec<_>>().join("\n\n");
        let h_source = sources.iter().map(|x| x.1.as_str()).collect::<Vec<_>>().join("\n");
        log::info!("======== C source ========\n{}", c_source);
        log::info!("======== h source ========\n{}", h_source);
        Ok(None)
    }
}
